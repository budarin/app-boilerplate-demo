<!doctype html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Тест центрирования иконки splash screen по экрану</title>
        <style>
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                overflow: hidden;
                margin: 0;
                padding: 0;
            }

            .icon {
                position: fixed;
                inset-block-start: var(--icon-top, 50%);
                inset-inline-start: var(--icon-left, 50%);
                transform: translate(-50%, -50%);

                inline-size: 120px;
                block-size: 120px;
                border-radius: 50%;

                background: linear-gradient(135deg, #41d1ff 0%, #bd34fe 100%);
            }

            .debug-panel {
                pointer-events: auto;
                cursor: pointer;

                position: fixed;
                inset-block-start: 10px;
                inset-inline-end: 10px;

                padding: 8px;
                border-radius: 4px;

                font-family: monospace;
                font-size: 10px;
                line-height: 1.3;
                color: #000;

                background: rgb(255 255 255 / 70%);
            }

            .debug-row {
                margin-block-end: 2px;
                white-space: nowrap;
            }
        </style>
    </head>
    <body>
        <div class="icon" id="icon"></div>
        <div class="debug-panel" id="debugPanel"></div>

        <script>
            const STORAGE_PREFIX = 'splash_screen_offsets_';

            function getOrientation() {
                if (screen.orientation && typeof screen.orientation.angle !== 'undefined') {
                    return screen.orientation.angle;
                }
                return window.orientation || 0;
            }

            function getStorageKey() {
                const angle = getOrientation();
                return `${STORAGE_PREFIX}${angle}`;
            }

            // ===== Работа с localStorage =====

            function loadOffsets() {
                const key = getStorageKey();
                const stored = localStorage.getItem(key);
                if (stored) {
                    try {
                        return JSON.parse(stored);
                    } catch (e) {
                        return null;
                    }
                }
                return null;
            }

            function saveOffsets(topOffset, leftOffset) {
                const key = getStorageKey();
                const data = {
                    top: topOffset,
                    left: leftOffset,
                };
                localStorage.setItem(key, JSON.stringify(data));
            }

            // ===== Калибровка через touchstart =====

            function calibrate(event) {
                const touch = event.touches ? event.touches[0] : event;
                let screenX = touch.screenX;
                let screenY = touch.screenY;
                const clientX = touch.clientX;
                const clientY = touch.clientY;

                // Проверяем доступность screenX/Y
                if (
                    typeof screenX === 'undefined' ||
                    typeof screenY === 'undefined' ||
                    screenX === 0 ||
                    screenY === 0
                ) {
                    // Fallback для десктопа
                    if (window.screenX > 0 || window.screenY > 0) {
                        screenX = window.screenX + clientX;
                        screenY = window.screenY + clientY;
                    } else {
                        // На мобильном без screenX/Y - используем вычисленные из размеров
                        const diffHeight = window.screen.height - window.innerHeight;
                        const diffWidth = window.screen.width - window.innerWidth;
                        screenX = clientX + (diffWidth > 0 ? diffWidth / 2 : 0);
                        screenY = clientY + (diffHeight > 0 ? diffHeight / 2 : 0);
                    }
                }

                // Вычисляем offset'ы от краёв экрана
                const topOffset = screenY - clientY;
                const leftOffset = screenX - clientX;

                // Обновляем отладочную панель
                updateDebugPanel({
                    screenY,
                    clientY,
                    topOffset,
                    screenX,
                    clientX,
                    leftOffset,
                    debugInfo: `calibrate called: top=${topOffset.toFixed(1)}, left=${leftOffset.toFixed(1)}`,
                });

                // Загружаем существующие значения
                const existing = loadOffsets();

                // Проверяем, изменились ли значения (с погрешностью 1px)
                const hasChanged =
                    !existing ||
                    Math.abs(existing.top - topOffset) > 1 ||
                    Math.abs(existing.left - leftOffset) > 1;

                if (hasChanged) {
                    saveOffsets(topOffset, leftOffset);
                }

                // Всегда применяем offset'ы после касания
                applyOffsets(topOffset, leftOffset);
            }

            // ===== Применение offset'ов к CSS переменным =====

            function applyOffsets(topOffset, leftOffset) {
                // Если нет touch (десктоп), центрируем по viewport
                if (!('ontouchstart' in window)) {
                    document.documentElement.style.setProperty('--icon-top', '50%');
                    document.documentElement.style.setProperty('--icon-left', '50%');
                    return;
                }

                // Вычисляем позицию центра экрана в координатах viewport
                const screenCenterY = window.screen.height / 2;
                const screenCenterX = window.screen.width / 2;

                const iconTop = screenCenterY - topOffset;
                const iconLeft = screenCenterX - leftOffset;

                // Обновляем отладочную панель
                updateDebugPanel({
                    screenCenterY,
                    screenCenterX,
                    iconTop,
                    iconLeft,
                    topOffset,
                    leftOffset,
                });

                document.documentElement.style.setProperty('--icon-top', `${iconTop.toFixed(2)}px`);
                document.documentElement.style.setProperty(
                    '--icon-left',
                    `${iconLeft.toFixed(2)}px`
                );
            }

            // ===== Отладочная панель =====

            function updateDebugPanel(data = {}) {
                const panel = document.getElementById('debugPanel');
                if (!panel) return;

                const offsets = loadOffsets();
                const screenHeight = window.screen.height;
                const screenWidth = window.screen.width;
                const innerHeight = window.innerHeight;
                const innerWidth = window.innerWidth;
                const orientation = getOrientation();

                const computedStyle = getComputedStyle(document.documentElement);
                const iconTop = computedStyle.getPropertyValue('--icon-top').trim();
                const iconLeft = computedStyle.getPropertyValue('--icon-left').trim();

                const debugText = `
Ориентация: ${orientation}°
Экран: ${screenWidth}×${screenHeight}
Viewport: ${innerWidth}×${innerHeight}
${
    offsets
        ? `Top offset: ${offsets.top.toFixed(1)}px
Left offset: ${offsets.left.toFixed(1)}px`
        : 'Не калибровано'
}
${
    data.screenCenterY !== undefined
        ? `Центр экрана Y: ${data.screenCenterY.toFixed(1)}px
Центр экрана X: ${data.screenCenterX?.toFixed(1) || '—'}px
Иконка top: ${data.iconTop?.toFixed(1) || '—'}px
Иконка left: ${data.iconLeft?.toFixed(1) || '—'}px`
        : ''
}
${
    data.screenY !== undefined
        ? `Touch screenY: ${data.screenY.toFixed(1)}
Touch clientY: ${data.clientY.toFixed(1)}
Touch screenX: ${data.screenX?.toFixed(1) || '—'}
Touch clientX: ${data.clientX?.toFixed(1) || '—'}`
        : ''
}
CSS top: ${iconTop || '50%'}
CSS left: ${iconLeft || '50%'}
hasBeenActive: ${navigator.userActivation?.hasBeenActive || false}
${data.debugInfo ? `DEBUG: ${data.debugInfo}` : ''}
`;

                panel.innerHTML = debugText
                    .split('\n')
                    .filter((line) => line.trim())
                    .map((line) => `<div class="debug-row">${line}</div>`)
                    .join('');

                // Добавляем обработчик клика для копирования
                panel.onclick = () => {
                    navigator.clipboard.writeText(debugText.trim()).then(() => {
                        const originalBg = panel.style.background;
                        panel.style.background = 'rgb(144 238 144 / 70%)';
                        setTimeout(() => {
                            panel.style.background = originalBg;
                        }, 200);
                    });
                };
            }

            // ===== Инициализация offset'ов при загрузке =====

            function initializeOffsets() {
                const offsets = loadOffsets();
                if (offsets) {
                    applyOffsets(offsets.top, offsets.left);
                    return true;
                }
                // Если нет offset'ов и нет touch - центрируем по viewport (для десктопа)
                if (!('ontouchstart' in window)) {
                    applyOffsets(0, 0);
                }
                return false;
            }

            // ===== Обработка смены ориентации =====

            function handleOrientationChange() {
                // Даем время браузеру обновить размеры после смены ориентации
                setTimeout(() => {
                    const currentOrientation = getOrientation();
                    const offsets = loadOffsets();

                    updateDebugPanel({
                        debugInfo: `Orientation changed to ${currentOrientation}°, hasOffsets: ${!!offsets}`,
                    });

                    if (offsets) {
                        applyOffsets(offsets.top, offsets.left);
                        updateDebugPanel();
                    } else {
                        // Если нет offset'ов для новой ориентации
                        if (navigator.userActivation?.hasBeenActive) {
                            // Пользователь уже взаимодействовал - ищем любые сохраненные offset'ы
                            let estimatedTopOffset = 0;
                            let estimatedLeftOffset = 0;

                            // Пробуем найти offset'ы из других ориентаций
                            for (let angle = 0; angle <= 270; angle += 90) {
                                const key = `${STORAGE_PREFIX}${angle}`;
                                const stored = localStorage.getItem(key);
                                if (stored) {
                                    try {
                                        const data = JSON.parse(stored);
                                        estimatedTopOffset = data.top || 0;
                                        estimatedLeftOffset = data.left || 0;
                                        break;
                                    } catch (e) {
                                        // игнорируем ошибки парсинга
                                    }
                                }
                            }

                            // Если не нашли, вычисляем из размеров (симметричное смещение)
                            if (estimatedTopOffset === 0 && estimatedLeftOffset === 0) {
                                const diffHeight = window.screen.height - window.innerHeight;
                                const diffWidth = window.screen.width - window.innerWidth;
                                estimatedTopOffset = diffHeight > 0 ? diffHeight / 2 : 0;
                                estimatedLeftOffset = diffWidth > 0 ? diffWidth / 2 : 0;
                            }

                            // Создаем синтетическое событие с вычисленными координатами
                            const centerX = window.innerWidth / 2;
                            const centerY = window.innerHeight / 2;
                            const screenX = centerX + estimatedLeftOffset;
                            const screenY = centerY + estimatedTopOffset;

                            const touch = new Touch({
                                identifier: Date.now(),
                                target: document.body,
                                clientX: centerX,
                                clientY: centerY,
                                screenX: screenX,
                                screenY: screenY,
                                radiusX: 5,
                                radiusY: 5,
                                rotationAngle: 0,
                                force: 0.5,
                            });

                            const customEvent = new TouchEvent('touchstart', {
                                bubbles: true,
                                cancelable: true,
                                touches: [touch],
                                targetTouches: [touch],
                                changedTouches: [touch],
                                ctrlKey: false,
                                shiftKey: false,
                                altKey: false,
                                metaKey: false,
                            });

                            // Диспатчим событие напрямую в calibrate
                            calibrate(customEvent);
                            updateDebugPanel({
                                debugInfo: `Synthetic event sent: estTop=${estimatedTopOffset.toFixed(1)}, estLeft=${estimatedLeftOffset.toFixed(1)}`,
                            });
                        } else {
                            // Пользователь еще не взаимодействовал - вешаем одноразовый обработчик
                            document.addEventListener('touchstart', calibrate, {
                                passive: true,
                                once: true,
                            });
                            updateDebugPanel({
                                debugInfo: 'Waiting for user touch...',
                            });
                        }
                    }
                }, 150);
            }

            function init() {
                // Регистрируем обработчик touchstart для калибровки
                if ('ontouchstart' in window) {
                    document.addEventListener('touchstart', calibrate, { passive: true });
                }

                // Регистрируем обработчики смены ориентации
                if ('ontouchstart' in window) {
                    window.addEventListener('orientationchange', handleOrientationChange);
                    if (screen.orientation) {
                        screen.orientation.addEventListener('change', handleOrientationChange);
                    }
                }

                // Загружаем offset'ы при запуске
                initializeOffsets();

                // Обновляем отладочную панель
                updateDebugPanel();
            }

            init();
        </script>
    </body>
</html>
